# -*- coding: utf-8 -*-
"""deep_dream.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11XWck9esQlNOAHL-UQHAmSba00O1ycem
"""

"""
Created on Mon Nov 21 21:57:29 2017

@author: Utku Ozbulak - github.com/utkuozbulak
"""
import os
from PIL import Image

import torch
import numpy as np
from torch.optim import SGD
from torchvision import models

import nibabel as nb

from pytorch_cnn_visualizations.src.misc_functions import preprocess_image, recreate_image, save_image


class DeepDream():
    """
        Produces an image that minimizes the loss of a convolution
        operation for a specific layer and filter
    """
    def __init__(self, model, selected_layer, selected_filter, im_path, low,high, size,  method = None):
        self.model = model
        self.model.eval()
        self.selected_layer = selected_layer
        self.selected_filter = selected_filter
        self.conv_output = 0
        self.method = method
        # Generate a random image
        #self.created_image = Image.open(im_path).convert('RGB')
        self.created_image =np.uint8(np.random.uniform(low, high, size))
        # Hook the layers to get result of the convolution
        self.hook_layer()
        self.im_path = im_path
        # Create the folder to export images if not exists
        #if not os.path.exists('/content/drive/My Drive/Colab Notebooks/results/new_ddgenerated'):
            #os.makedirs('/content/drive/My Drive/Colab Notebooks/results/new_ddgenerated')

    def hook_layer(self):
        def hook_function(module, grad_in, grad_out):
            # Gets the conv output of the selected filter (from selected layer)
            self.conv_output = grad_out[0, self.selected_filter]

        # Hook the selected layer
        # Change by Arnab Das
        #for index, layer in (self.model._modules.items()):
        #    if index == self.selected_layer:
        #        layer[-1].register_forward_hook(hook_function)

        eval(f"self.model.{self.selected_layer}").register_forward_hook(hook_function)
        #list(self.model._modules.items())[self.selected_layer][-1].register_forward_hook(hook_function)
        #self.model[self.selected_layer].register_forward_hook(hook_function)

    def dream(self, device, affine_size= 4, is_3d= False, update_count= 250, is_depth_first=False):
        # Process image and return variable
        if type(self.created_image) is not np.ndarray: self.created_image = np.asarray(self.created_image)
        #if not is_3d:
        #    self.processed_image = preprocess_image(self.created_image, True)

        else:
            self.processed_image = torch.from_numpy(self.created_image).float()
            self.processed_image /= 255
            self.processed_image -= 0.485
            self.processed_image /= 0.229

        self.processed_image.requires_grad = True

        # Define optimizer for the image
        # Earlier layers need higher learning rates to visualize whereas layer layers need less
        optimizer = SGD([self.processed_image], lr=12,  weight_decay=1e-4)
        for i in range(1, 251):
            optimizer.zero_grad()
            # Assign create image to a variable to move forward in the model
            x = self.processed_image.to(device)
            for index, layer in (self.model._modules.items()):
                # Forward
                if (index=='fc'): x=x.flatten(1)
                x = layer(x)
                # Only need to forward until we the selected layer is reached
                if index == self.selected_layer:
                    break
            # Loss function is the mean of the output of the selected layer/filter
            # We try to minimize the mean of the output of that specific filter
            loss = -torch.mean(self.conv_output)
            #print('Iteration:', str(i), 'Loss:', "{0:.2f}".format(loss.data.cpu().numpy()))
            # Backward
            loss.backward()
            # Update image
            optimizer.step()
            # Recreate image
            if not is_3d and self.method is None:self.created_image = recreate_image(self.processed_image)
            else:
                self.created_image = self.processed_image
            # Save image every 20 iteration
            if i % update_count == 0:
                #print(self.created_image.shape)
                if is_3d== False:

                    im_path = f"{self.im_path}CNN_Vis_DeepDream_{str(self.selected_layer)}_f{str(self.selected_filter)}_iter{str(i)}.png"

                    save_image(self.created_image, im_path)
                else:
                    im_path = f"{self.im_path}CNN_Vis_DeepDream_{str(self.selected_layer)}_f{str(self.selected_filter)}_iter{str(i)}.nii.gz"

                    grads = self.created_image.squeeze().cpu().detach().numpy()
                    if is_depth_first:
                        grads= np.moveaxis(grads, 0, -1)

                    img = nb.Nifti1Image(grads, np.eye(affine_size))
                    nb.save(img, im_path)


if __name__ == '__main__':
    # THIS OPERATION IS MEMORY HUNGRY! #
    # Because of the selected image is very large
    # If it gives out of memory error or locks the computer
    # Try it with a smaller image
    cnn_layer = 8
    filter_pos = 8

    im_path = '/content/images.jpg'
    # Fully connected layer is not needed
    pretrained_model = models.vgg16(pretrained=True).features
    dd = DeepDream(pretrained_model, cnn_layer, filter_pos, im_path)
    # This operation can also be done without Pytorch hooks
    # See layer visualisation for the implementation without hooks
    dd.dream()